#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int a[N];
int dp[N];
int main ()
{
	int n;
	cin>>n;
	for(int i= 1;i<=n;i++) cin>>a[i];
    if(a[1] >= 0) dp[1] = a[1];
    else dp[1] = 0;
    int ans = -1e9;
    int temp = 0;
    for(int i= 1;i<=n;i++)
	{
       dp[i] = (dp[i-1]+a[i]) >= a[i]?dp[i-1]+a[i]:a[i];
       ans = max(dp[i],ans);
	}
    cout<<ans<<endl;
	return 0 ;
}
/*
动态规划的基本原理这里不再赘述，主要讨论这个问题的建模过程和子问题结构.时刻记住一个前提，这里是连续的区间

令b[j]表示以位置 j 为终点的所有子区间中和最大的一个
子问题:如j为终点的最大子区间包含了位置j-1,则以j-1为终点的最大子区间必然包括在其中
如果b[j-1] >0, 那么显然b[j] = b[j-1] + a[j]，用之前最大的一个加上a[j]即可，因为a[j]必须包含
如果b[j-1]<=0,那么b[j] = a[j] ,因为既然最大，前面的负数必然不能使你更大
对于这种子问题结构和最优化问题的证明，可以参考算法导论上的“剪切法”，即如果不包括子问题的最优解，把你假设的解粘帖上去，会得出子问题的最优化矛盾.证明如下：

令a[x,y]表示a[x]+…+a[y] , y>=x
假设以j为终点的最大子区间 [s, j] 包含了j-1这个位置，以j-1为终点的最大子区间[ r, j-1]并不包含其中
即假设[r,j-1]不是[s,j]的子区间
存在s使得a[s, j-1]+a[j]为以j为终点的最大子段和,这里的 r != s 
由于[r, j -1]是最优解, 所以a[s,j-1]<a[r, j-1],所以a[s,j-1]+a[j]<a[r, j-1]+a[j]
与[s,j]为最优解矛盾.
*/